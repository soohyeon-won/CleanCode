## 13. 동시성 (226p ~ 244p)

객체 = 처리의 추상화
스레드 = 일정의 추상화

#### 들어가며
동시성과 깔끔한 코드는 양립하기 어렵다
여러 스레드를 동시에 돌리는 이유를 논함
"깨끗한 동시성"

#### 동시성이 필요한 이유?
결합을 없애는 전략
무엇과 언제를 분리하는 전략

#### 동시성에 대한 타당한 생각
1. 동시성은 다소 부하를 유발한다.
2. 동시성은 복잡하다
3. 동시성 버그는 재현하기 어렵다
4. 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다.

#### 동시성 방어 원칙
1. 단일 책임 원칙 SRP
- 주어진 메서드/클래스/컴포넌트를 변경할 이유가 하나여야 한다는 원칙
- 동시성 코드는 다른 코드와 분리하라.

: 자료범위를 제한하라 (corollary)
임계영역을 synchronized 키워드로 보호

: 자료 사본을 사용
객체를 복사해 읽기전용으로 사용
각 스레드가 객체를 복사해 사용 후 한 스레드가 해당 사본에서 결과를 가져오는 방법
객체 복사시간, 부하 걱정 => 복사 비용이 진짜 문제인지 실측

: 스레드는 가능한 독립적으로 구현
다른 스레드와 자료 공유X
각 스레드는 클라이언트 요청 하나를 처리한다.
비고

2. 라이브러리를 이해하라
Java의 경우 스레드 환경에 안전한 컬렉션 존재
언어가 제공하는 클래스를 검토하라 (락, 세마포)

3. 실행 모델을 이해하라
: 생산자-소비자
버퍼, 대기열(한정된 자원)
대기열에 빈 공간이 있어야 정보를 채운다

: 읽기-쓰기
처리율 (주의 기아현상)

: 식사하는 철학자들

4. 동기화하는 메서드 사이에 존재하는 의존성을 이해하라
- 공유 객체 하나에는 메서드 하나만 사용하라.
- 예외의 경우: 클라이언트에서 잠금, 서버에서 잠금, 연결 서버

5. 동기화하는 부분을 작게 만들어라

6. 올바른 종료 코드는 구현하기 어렵다.

7. 스레드 코드 테스트하기
다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자
POJO (특별한 객체가 아니라 평범한 자바 객체)

방법1: wait(), sleep(), yield(), priority() 함수를 코드에 직접추가
방법2: 자동화
AOF(Aspect-Oriented Framework), CGLIB, ASM등과 같은 도구 사용

[ 결론 ]
SRP 준수
POJO를 사용해 스레드를 아는 코드와 모르는 코드를 분리
스레드 코드를 테스트할 때는 전적으로 스레드만 테스트 (즉, 스레드 코드는 최대한 집약되고 작아야함)
동시성 오류를 일으키는 잠정적인 원인을 철저히 이해 (여러 스레드가 공유 자료를 조작, 자원 풀을 공유)
사용하는 라이브러리, 기본 알고리즘 이해
보호할 코드 영역을 찾아내는 방법과 특정 코드 영역을 잠그는 방법을 이해한다
